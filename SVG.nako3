#-----------------------------------------------
＃ 【 SVG描画 】　0.7.5

//・照明フィルター追加
//・グラデーション修正

※　制作時のナデシコバージョン:3.3.74（blob作成を使っているのでv3.3.67以上必要）
#-----------------------------------------------
＃定数宣言
定数 無色＝「none」。
定数 SVGデフォルト値一覧＝{
    "stroke":無色,
    "stroke-width":1,
    "stroke-opacity":1,
    "stroke-linecap":"butt",
    "stroke-linejoin":"miter",
    "stroke-dasharray":"none",
    "stroke-dashoffset":0,
    "fill":黒色,
    "fill-opacity":1,
    "font-family":空,
    "font-weight":"normal",
    "font-size":"medium",
}

＃変数宣言
変数 SVG要素作成個数＝0。
変数 SVG描画設定情報＝{
  "線":{
    "stroke":無色,
    "stroke-width":1,
    "stroke-opacity":1,
    "stroke-linecap":"butt",
    "stroke-linejoin":"miter",
    "stroke-dasharray":"none",
    "stroke-dashoffset":0,
  },
  "塗":{
    "fill":黒色,
    "fill-opacity":1,
  },
  "文字":{
    "font-family":空,
    "font-weight":"normal",
    "font-size":"medium",
  }
}
変数 SVGパス作成情報＝{"連続パス作成中フラグ":オフ}
変数 SVGドラッグ情報＝{"移動中フラグ":オフ}
変数 SVG対象フィルター＝空。

SVG和スタイル追加。
●SVG和スタイル追加
　追加和スタイル＝{
    "線色": "stroke",
    "線太":"stroke-width",
    "線太さ":"stroke-width",
    "線透明度":"stroke-opacity",
    "線端形状":"stroke-linecap",
    "端切":"butt",
    "円":"round",
    "丸":"round",
    "四角":"square",
    "角形状":"stroke-linejoin",
    "鋭角":"miter",
    "丸め":"round",
    "面取":"bevel",
    "面取り":"bevel",
    "破線パターン":"stroke-dasharray",
    "破線開始位置":"stroke-dashoffset",
    "塗色": "fill",
    "塗り色": "fill",
    "塗透明度":"fill-opacity",
    "塗り透明度":"fill-opacity",
    "透明度":"opacity",
    "フォント名":"font-family",
    "文字太":"font-weight",
    "文字太さ":"font-weight",
    "文字間":"letter-spacing",
    "元画像":"SourceGraphic",
    "影":"SourceAlpha"
  }
　追加和スタイルを反復
　　DOM和スタイル[対象キー]＝対象。
　ここまで。
ここまで。
#-----------------------------------------------
＃描画開始
//単なるDOM要素設定だけど、キャンバスの描画命令に寄せる＆クリップやマスクの描画開始が分かりやすくなる感。
●(svgの|svgへ|svgで)SVG描画開始
    svgへDOM親要素設定。
ここまで。
#-----------------------------------------------
＃図形描画
＃＃線
●(xy1からxy2まで|xy2へ)SVG線描画
    変数 [x1,y1]＝xy1。
    変数 [x2,y2]＝xy2。
    EL＝「line」のSVGエレメント作成。
    ELに{「x1」:x1,「y1」:y1,「x2」:x2,「y2」:y2}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

＃＃四角
●(xywhの|xywhへ|xywhに)SVG四角描画
    変数 [x,y,w,h]＝xywh。
    EL＝「rect」のSVGエレメント作成。
    ELに{「x」:x,「y」:y,「width」:w,「height」:h}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(xywhへrの|xywhにrで)SVG角丸四角描画
    もし、r[1]＝未定義ならば、r＝[r,r]。
    変数 [x,y,w,h]＝xywh。変数 [rx,ry]＝r。
    EL＝「rect」のSVGエレメント作成。
    ELに{「x」:x,「y」:y,「width」:w,「height」:h,「rx」:rx,「ry」:ry}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

＃＃円、楕円
●(xyへrの|xyに)SVG円描画
    変数 [x,y]＝xy。
    EL＝「circle」のSVGエレメント作成。
    ELに{「cx」:x,「cy」:y,「r」:r}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

●(xyへrの|xyに)SVG楕円描画
    もし、r[1]＝未定義ならば、r＝[r,r]。
    変数 [x,y]＝xy。変数 [rx,ry]＝r。
    EL＝「ellipse」のSVGエレメント作成。
    ELに{「cx」:x,「cy」:y,「rx」:rx,「ry」:ry}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

＃＃ポリゴン、ポリライン
# PはSVGの記述通り「x1,y1 x2,y2 x3,y3...」と、なでしこのキャンバスのと同じ配列での指定ができる[[x2,y1],[x2,y2],[x3,y3]...]
# 線だけにしたい場合は、SVG塗り色を「none」にする。
●(Pの|Pで)SVG折れ線描画
    もし、(Pの変数型確認)＝「object」ならば、P=Pを「 」で配列結合。
    EL＝「polyline」のSVGエレメント作成。
    ELの「points」にPをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

●(Pの|Pで)SVG多角形描画
    もし、(Pの変数型確認)＝「object」ならば、P=Pを「 」で配列結合。
    EL＝「polygon」のSVGエレメント作成。
    ELの「points」にPをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。
#-----------------------------------------------
＃文字描画
●(xyへSの|xyにSを)SVG文字描画
    変数 [x,y]＝xy。
    EL＝「text」のSVGエレメント作成。
    ELに{「x」:x,「y」:y}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    ELにSVG描画設定情報["文字"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELにSをテキスト設定。
    ELを戻す。
ここまで。

●(xyへSの|xyにSを)SVG縦書き文字描画
    変数 [x,y]＝xy。
    EL＝「text」のSVGエレメント作成。
    ELに{「x」:x,「y」:y,
         「writing-mode」:「vertical-rl」,
         「text-orientation」:「mixed」}をSVG属性一括設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    ELにSVG描画設定情報["文字"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELにSをテキスト設定。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃パス描画
●(dの|dを|dで)SVGパス描画
    EL＝「path」のSVGエレメント作成。
    ELの「d」にdをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

＃＃連続パス描画
//連続パス描画中は始点を省略してつないでいく。
●(始点から|始点に|始点へ)SVG連続パス描画開始
    SVGパス作成情報["連続パス作成中フラグ"]＝オン。
    SVGパス作成情報["d"]＝空。
    もし、(始点＝空)または((始点の要素数)≠2)でなければ、SVGパス作成情報["d"]＝「M {始点[0]},{始点[1]} 」
    SVGパス作成情報["d"]で戻る。
ここまで。

●SVG連続パス描画終了
    SVGパス作成情報["連続パス作成中フラグ"]＝オフ。
    SVGパス作成情報["d"]でSVGパス描画。
ここまで。

●(追加パスで)SVG連続パス追加処理
    SVGパス作成情報["d"]＝SVGパス作成情報["d"]&追加パス。
    SVGパス作成情報["d"]で戻る。
ここまで。

//連続パス描画でだけ
●(xyへ|xyに|xyまで)SVGパス描画位置移動
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オフならば、戻る。
    追加パス＝「M {xy[0]},{xy[1]} 」
    追加パスでSVG連続パス追加処理して、戻る。
ここまで。

＃＃線
●(xy1からxy2まで|xy2へ)SVGパス線描画
    x1,y1＝xy1。x2,y2＝xy2。
    始点＝「M {x1},{y1} 」。追加パス＝「L {x2},{y2} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
    d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

＃＃弧
//設定配列=[回転度,弧が180度より大きいか,時計回りか]
●(始点から終点まで設定配列で半径の)SVG弧形描画
    始点＝「M {始点[0]},{始点[1]} 」。
    もし、設定配列＝空ならば、設定配列＝[0,0,1]。
    回転度,大弧,右回転＝設定配列。
    半径x,半径y＝半径。もし、半径y＝未定義ならば、半径y＝半径x。
    追加パス＝「A {半径x},{半径x} {回転度} {大弧} {右回転} {終点[0]} {終点[1]} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
    d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

# 角度はラジアン。角度0は右端。
●(中点に開始角から終了角まで半径の|中点へ半径で)SVG扇描画
    中点x,中点y＝中点。
    開始角＝開始角のラジアン角度修正。
    終了角＝終了角のラジアン角度修正。
    半径x,半径y＝半径。もし、半径y＝未定義ならば、半径y＝半径x。
    x1＝半径x*COS(開始角)＋中点x。
    y1＝半径y*SIN(開始角)＋中点y。
    x2＝半径x*COS(終了角)＋中点x。
    y2＝半径y*SIN(終了角)＋中点y。
    回転度＝0。     # 回転度
    大弧＝いいえ。  # 弧が180度より大きいか
    もし、終了角＜開始角ならば、終了角＝終了角+(360をラジアン変換)
    もし、終了角-開始角＞(180をラジアン変換)ならば、大弧＝はい。
    右回転＝はい。  # 時計回りか
    d＝「M {中点x},{中点y} L {x1},{y1} A {半径x},{半径y} {回転度} {大弧} {右回転} {x2},{y2} z 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、dでSVG連続パス追加処理して、戻る。
    dでSVGパス描画。
ここまで。

●(中点に開始角から終了角まで半径の|中点へ半径で)SVG円弧描画
    中点x,中点y＝中点。
    開始角＝開始角のラジアン角度修正。
    終了角＝終了角のラジアン角度修正。
    半径x,半径y＝半径。もし、半径y＝未定義ならば、半径y＝半径x。
    x1＝半径x*COS(開始角)＋中点x。
    y1＝半径y*SIN(開始角)＋中点y。 
    x2＝半径x*COS(終了角)＋中点x。
    y2＝半径y*SIN(終了角)＋中点y。
    回転度＝0。     # 回転度
    大弧＝いいえ。  # 弧が180度より大きいか
    もし、終了角＜開始角ならば、終了角＝終了角+(360をラジアン変換)
    もし、終了角-開始角＞(180をラジアン変換)ならば、大弧＝はい。
    右回転＝はい。  # 時計回りか
    d＝「M {x1},{y1} A {半径x},{半径y} {回転度} {大弧} {右回転} {x2},{y2} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、dでSVG連続パス追加処理して、戻る。
    dでSVGパス描画。
ここまで。

●(ラジアン度の)ラジアン角度修正　//0～360をラジアン変換の範囲に修正
    修正ラジアン度＝ラジアン度%(360をラジアン変換)
    もし、修正ラジアン度＜０ならば、修正ラジアン度＝修正ラジアン度+(360をラジアン変換)
    修正ラジアン度で戻る。
ここまで。

＃＃スプライン
●(始点から中継点配列で)SVGスプライン描画
    始点＝「M {始点[0]},{始点[1]} 」
    追加パス＝空。
　　中継点配列を反復
　　　　点x,点y＝中継点配列[対象キー]
　　　　追加パス＝追加パス&「T {点x},{点y} 」
　　ここまで。
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
　　d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

＃＃ベジェ曲線
# 終点を配列にして複数指定すると、スプラインでつないでいく。
●(始点から制御点で終点まで|始点と終点の)SVG二次ベジェ曲線描画
    始点＝「M {始点[0]},{始点[1]} 」
    制御点＝「Q {制御点[0]},{制御点[1]} 」
    追加パス＝制御点。
    もし、(終点[0]の要素数)＝１ならば、
        追加パス＝追加パス&「{終点[0]},{終点[1]} 」
    違えば、
        終点を反復
            もし、対象キー≠0ならば、追加パス＝追加パス&「T 」。
            追加パス＝追加パス&「{対象[0]},{対象[1]} 」。
        ここまで。
    ここまで。
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
　　d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

●(始点から制御点配列で終点まで|始点と終点の)SVG三次ベジェ曲線描画
    始点＝「M {始点[0]},{始点[1]} 」
    制御点A,制御点B＝制御点配列。
    追加パス＝「C {制御点A[0]},{制御点A[1]} {制御点B[0]},{制御点B[1]} {終点[0]},{終点[1]} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
　　d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

//連続パス描画でだけ
●(制御点で終点まで|終点と)SVG三次ベジェ曲線続ける
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オフならば、戻る。
    もし、(終点[0]の要素数)＝1ならば、
        追加パス＝「S {制御点[0]},{制御点[1]} {終点[0]},{終点[1]} 」
        追加パスでSVG連続パス追加処理して、戻る。
    違えば、
        (終点の要素数)回。
            終点x,終点y＝終点[回数-1]。
            制御点x,制御点y＝制御点[回数-1]。
            追加パス＝「S {制御点x},{制御点y} {終点x},{終点y} 」
            追加パスでSVG連続パス追加処理。
        ここまで。
        戻る。
    ここまで。
ここまで。
#-----------------------------------------------
＃画像描画
# 幅と高さの指定が必須ラシイ(無くても等幅で表示される気がするけどいちおう)
# https://developer.mozilla.org/ja/docs/Web/SVG/Element/image
●(xywhへURLの|xywhにURLを)SVG画像描画
    変数 [x,y,w,h]＝xywh。
    EL＝「image」のSVGエレメント作成。
    ELに{「x」:x,「y」:y,「width」:w,「height」:h,「href」:URL}をSVG属性一括設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。
#-----------------------------------------------
＃作成
●(要素種別の)SVGエレメント作成。
    EL＝「document」の「createElementNS」を['http://www.w3.org/2000/svg',要素種別]でJSメソッド実行。
    ELの「id」に「nako3-svg-{SVG要素作成個数}」をSVG属性設定。
    SVG要素作成個数＝SVG要素作成個数+1。
    ELを戻す。
ここまで。

＃＃ＳＶＧ親要素
●(whの|whで)SVG親要素作成
    変数 [w,h]＝wh。
    EL＝「svg」のSVGエレメント作成。
    ELの「setAttribute」を['xmlns','http://www.w3.org/2000/svg']でJSメソッド実行。
    ELの「setAttribute」を['xmlns:xlink','http://www.w3.org/1999/xlink']でJSメソッド実行。
    ELの「viewBox」に「0 0 {w} {h}」をSVG属性設定。
    ELの「width」にwをSVG属性設定。
    ELの「height」にhをSVG属性設定。
    DOM親要素へELをDOM子要素追加。
    ELへDOM親要素設定。
    ELを戻す。
ここまで。
#-----------------------------------------------
※今のところなでしこに関数の引数省略時の設定が無いので、引数が一つだと省略がうまく働かない。
//「ｘｘ＝SVGグループ作成」はできない。
//「SVGグループ作成してｘｘに代入」はうまくいくようだが今後ダメになる可能性もある。

＃＃グループ
# グループ化。表示される。スタイルやトランスフォーム属性を指定すると一括で指定される。
●(親要素へ|親要素に)SVGグループ作成
    もし、親要素＝空ならば、親要素＝DOM親要素。
    EL＝「g」のSVGエレメント作成。
    親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

# ここに描画したものは表示されない。参照複製(use)して使うものを定義しておく所。
# viewbox を指定でき、参照複製時、width, height を指定して拡縮できる（？）
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGシンボルグループ作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「symbol」のSVGエレメント作成。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

# シンボルグループやスタイルシートなど実際に描画しないものを定義しておく所。
# 参照される要素は可能な限り、ここに入れておけとゆうことラシイ（？）
●(親要素へ|親要素に)SVG定義領域作成
    もし、親要素＝空ならば、親要素＝DOM親要素。
    EL＝「defs」のSVGエレメント作成。
    親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃＃参照複製
# 参照元の塗り色や線色や変形は継承されて上書き出来ないので気を付ける。
# 参照元は、シンボルグループの中に、スタイル属性やトランスフォーム属性は基本付けず作成。
# 色関係の変数には空を設定しておく。
# use(https://developer.mozilla.org/ja/docs/Web/SVG/Element/use)
●(svgを)SVG参照複製
    ID＝svgの「id」をSVG属性取得。
    EL＝「use」のSVGエレメント作成。
    ELの「href」に「#{ID}」をSVG属性設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃＃その他の要素
# 一応何でも作れるようにしておく
●(要素種別の)SVG要素作成。
    EL＝要素種別のSVGエレメント作成。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃設定と取得
# なでしこのDOM属性設定、取得命令では、SVGはできない。
# 「setAttribute」でいいのか「setAttributeNS」が正しいのか、なやむー。
●(svgの属性に値を|属性へ)SVG属性設定
    もし、(DOM和スタイルに属性が辞書キー存在）ならば、属性＝DOM和スタイル[属性]。
    もし、(DOM和スタイルに値が辞書キー存在）ならば、値＝DOM和スタイル[値]。
    svgの「setAttributeNS」を[NULL,属性,値]でJSメソッド実行。
ここまで。

●(svgに|svgへ設定を)SVG属性一括設定
    設定を反復
        属性＝対象キー。値＝対象。
        svgの属性に値をSVG属性設定。
    ここまで。
ここまで。

●(svgの属性を|属性から)SVG属性取得
    もし、(DOM和スタイルに属性が辞書キー存在）ならば、属性＝DOM和スタイル[属性]。
    svgの「getAttributeNS」を[NULL,属性]でJSメソッド実行。
ここまで。
#-----------------------------------------------
＃＃描画初期設定
#描画要素作成時に使う一括設定。
# スタイルやトランスフォームは直接指定すると、
# 　・優先順位によりクラスでの指定が効かなくなる。
# 　・参照複製時にも継承されて上書きできない。
# 　そうゆう用途の場合は、空またはデフォルト値にしておくことで設定しないようにする。
●(svgに設定を)SVG描画初期設定
    設定を反復
        属性＝対象キー。値＝対象。デフォルト値＝SVGデフォルト値一覧[属性]。
        もし、(値≠デフォルト値)かつ(値!==空)ならば、svgの属性に値をSVG属性設定。
    ここまで。
ここまで。
#-----------------------------------------------
＃＃描画スタイル設定
#なでしこのキャンバスの描画と同様、これから描画するやつに適用される。
●(Vに|Vへ)SVG線色設定
    SVG描画設定情報["線"]["stroke"]＝V。
ここまで。

●(Vに|Vへ)SVG塗色設定
    SVG描画設定情報["塗"]["fill"]＝V。
ここまで。

●(Vに|Vへ)SVG線太設定
    SVG描画設定情報["線"]["stroke-width"]＝V。
ここまで。

# [線透明度,塗り透明度]。値が一つの時は同じになる。
●(Vに|Vへ)SVG透明度設定
    線,塗＝V。
    もし、塗＝未定義ならば、塗＝V。
    SVG描画設定情報["線"]["stroke-opacity"]＝線。
    SVG描画設定情報["塗"]["fill-opacity"]＝塗。
ここまで。

●(Vに|Vへ)SVG線端形状設定
    もし、(DOM和スタイルにVが辞書キー存在）ならば、V＝DOM和スタイル[V]。
    SVG描画設定情報["線"]["stroke-linecap"]＝V。
ここまで。

●(Vに|Vへ)SVG角形状設定
    もし、(DOM和スタイルにVが辞書キー存在）ならば、V＝DOM和スタイル[V]。
    SVG描画設定情報["線"]["stroke-linejoin"]＝V。
ここまで。

＃＃フォント設定
●(Vに|Vへ)SVG文字フォント設定
    SVG描画設定情報["文字"]["font-family"]＝V。
ここまで。

●(Vに|Vへ)SVG文字太さ設定
    SVG描画設定情報["文字"]["font-weight"]＝V。
ここまで。

●(Vに|Vへ)SVG文字サイズ設定
    SVG描画設定情報["文字"]["font-size"]＝V。
ここまで。
#-----------------------------------------------
＃＃破線・点線
●(Aに|Aへ)SVG破線パターン設定
    もし、(Aの変数型確認)＝「object」でなければ、
        SVG線太さ＝SVG描画設定情報["線"]["stroke-width"]。
        「端切」にSVG線端形状設定。
        Aで条件分岐
            「丸点線」ならば、
                「丸」にSVG線端形状設定。
                A＝「1 {SVG線太さ*2}」。
            ここまで。
            「細点線」ならば、A＝SVG線太さ。。。
            「点線」ならば、A＝SVG線太さ*2。。。
            「破線」ならば、A＝「{SVG線太さ*4} {SVG線太さ*2}」。。。
            「一点鎖線」ならば、A＝「{SVG線太さ*6} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2}」。。。
            「中長破線」ならば、A＝「{SVG線太さ*6} {SVG線太さ*2}」。。。
            「長破線」ならば、A＝「{SVG線太さ*8} {SVG線太さ*2}」。。。
            「長鎖線」ならば、A＝「{SVG線太さ*8} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2}」。。。
            「二点鎖線」ならば、A＝「{SVG線太さ*8} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2}」。。。
            違えば、A＝「」。。。
    　　ここまで。
　　ここまで。
　　SVG描画設定情報["線"]["stroke-dasharray"]＝A。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃効果
#-----------------------------------------------
＃＃画像切り抜き
# クリッピングパスを定義して置く所。この中に描画したものは表示されず、画像切り抜きで設定して使う。
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGクリップパス作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「clipPath」のSVGエレメント作成。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgをクリップパスで)SVG画像切り抜き
    ID=クリップパスの「id」をSVG属性取得。
    svgの「clip-path」に「url(#{ID})」をSVG属性設定。
ここまで。
#-----------------------------------------------
＃＃マスキング
# マスクを定義しておく所。白色で描画した所は表示され、黒色または透明度０で描画した所は非表示になる。白色に透明度を設定すれば、半透明にもできる。
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGマスク作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「mask」のSVGエレメント作成。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgをマスクで)SVG画像マスキング
    ID=マスクの「id」をSVG属性取得。
    svgの「mask」に「url(#{ID})」をSVG属性設定。
ここまで。

＃＃グラデーション
# 基本、定義領域(defs)に作成する。
/*
stop配列は[[offset,stop-color,stop-opacity],[...]]の配列。
・x1,y1：勾配ベクトルの始点
・x2,y2：勾配ベクトルの終点
*/
●(stop配列で始点から終点まで定義領域へ|定義領域に終点の)SVG線形グラデーション作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    x1,y1＝始点。x2,y2＝終点。
　　EL＝「linearGradient」のSVGエレメント作成。
　　定義領域へELをDOM子要素追加。
　　ELへ{"x1":x1,"y1":y1,"x2":x2,"y2":y2}をSVG属性一括設定。
　　stop配列を反復
　　　　stop＝「stop」のSVGエレメント作成。
　　　　stopの「offset」に対象[0]をSVG属性設定。
　　　　stopの「stop-color」に対象[1]をSVG属性設定。
　　　　もし、対象[2]≠未定義ならば、stopの「stop-opacity」に対象[2]をSVG属性設定。
　　　　ELへstopをDOM子要素追加。
　　ここまで。
    ELを戻す。
ここまで。

/*
中点は[cx,cy]または[cx,cy,fx,fy]の配列。
・cx,cy：中点
・fx,fy：焦点
・r：半径
*/
●(stop配列で中点から半径まで定義領域へ|定義領域に半径の)SVG放射状グラデーション作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    cx,cy,fx,fy＝中点。
    設定＝{"cx":cx,"cy":cy,"fx":fx,"fy":fy,"r":半径}
    もし、fx＝未定義ならば、設定＝{"cx":cx,"cy":cy,"r":半径}
　　EL＝「radialGradient」のSVGエレメント作成。
　　定義領域へELをDOM子要素追加。
　　ELへ設定をSVG属性一括設定。
　　stop配列を反復
　　　　stop＝「stop」のSVGエレメント作成。
　　　　stopの「offset」に対象[0]をSVG属性設定。
　　　　stopの「stop-color」に対象[1]をSVG属性設定。
　　　　もし、対象[2]≠未定義ならば、stopの「stop-opacity」に対象[2]をSVG属性設定。
　　　　ELへstopをDOM子要素追加。
　　ここまで。
    ELを戻す。
ここまで。

●(svgの属性に|属性へグラデーションを)SVGグラデーション設定
    ID＝グラデーションの「id」をSVG属性取得。
    svgの属性に「url(#{ID})」をSVG属性設定。
ここまで。
#-----------------------------------------------
＃＃タイルパターン
# 基本、定義領域(defs)に作成する。
●(whで定義領域へ|定義領域に)SVGタイルパターン作成。
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    変数 [幅,高さ]＝wh。
    EL＝「pattern」のSVGエレメント作成。
    ELの「幅」に幅をSVG属性設定。
    ELの「高さ」に高さをSVG属性設定。
    # 適用先のサイズがどうでも、パターンのサイズ、比率は変えたくない。
    ELの「patternUnits」に「userSpaceOnUse」をSVG属性設定。
    ELの「patternContentUnits」に「userSpaceOnUse」をSVG属性設定。
    # 適用先の画像に対する比率で位置やサイズを設定する場合の設定。
    //ELの「patternUnits」に「objectBoundingBox」をSVG属性設定。
    //ELの「patternContentUnits」に「objectBoundingBox」をSVG属性設定。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgの属性に|属性へタイルパターンを)SVGタイルパターン設定
    ID=タイルパターンの「id」をSVG属性取得。
    # 適用先の画像の0,0からパターンが始まるようにする。
    タイルパターンの「x」に0をSVG属性設定。
    タイルパターンの「y」に0をSVG属性設定。
    svgの属性に「url(#{ID})」をSVG属性設定。
ここまで。
#-----------------------------------------------
＃フィルター
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGフィルター作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「filter」のSVGエレメント作成。
    ELの「filterUnits」に「userSpaceOnUse」をSVG属性設定。
    定義領域へELをDOM子要素追加。
    SVG対象フィルター＝EL。
    ELを戻す。
ここまで。

●(ELをフィルターへ|フィルターに)SVGフィルター追加
    もし、フィルター＝空ならば、フィルター＝SVG対象フィルター。
    もし、SVG対象フィルター＝空ならば、「先にフィルター作成」とコンソール表示。
    re＝ELの「id」をSVG属性取得。
    ELの「result」にreをSVG属性設定。
    フィルターへELをDOM子要素追加。
    reを戻す。
ここまで。

●(svgへ|svgにフィルターを)SVGフィルター設定
    もし、フィルター＝空ならば、フィルター＝SVG対象フィルター。
    もし、SVG対象フィルター＝空ならば、「先にフィルター作成」とコンソール表示。
    ID＝フィルターの「id」をSVG属性取得。
    svgの「filter」に「url(#{ID})」をSVG属性設定。
ここまで。

●(svgにフィルターで|フィルターにてsvgへELを)SVGフィルター直接設定
    もし、フィルター＝空ならば、フィルター＝SVG対象フィルター。
    もし、SVG対象フィルター＝空ならば、「先にフィルター作成」とコンソール表示。
    re＝フィルターにELをSVGフィルター追加。
    svgへフィルターをSVGフィルター設定。
    reを戻す。
ここまで。

＃＃画像処理フィルター
#ピクセルは偶数にしたほうがいいです。
●(ピクセルでsvgに|svgへ)SVG画像モザイク
    前画像＝SVGフィルター前画像取得。
    # ドットの作成
    黒色でSVG画像塗り潰し。
    それのDOM要素ID取得して{「x」: ピクセル/2,「y」:ピクセル/2,「幅」:1,「高さ」:1}をSVG属性一括設定。
    ドット＝[0,0]にSVG画像ズラし。
    それのDOM要素ID取得して{「x」: 0,「y」:0,「幅」:ピクセル,「高さ」:ピクセル}をSVG属性一括設定。
    ドットs＝ドットをSVG画像敷き詰め。
    # 元画像を合成
    前画像とドットsを「in」でSVG画像合成。
    # ドットをピクセルに拡張
    ピクセル/2でSVG画像膨張。
    svgにSVG対象フィルターをSVGフィルター設定。
ここまで。

●(強度でsvgへ|svgに強度の)SVG画像ボカシ　# feGaussianBlur
    EL＝「feGaussianBlur」のSVGエレメント作成。
    ELの「stdDeviation」に強度をSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

# 強度は（1〜20）。
●(強度でsvgへ|svgに強度の)SVG画像シャープ
    シャープ＝{「order」: 3,「targetX」: 1,「targetY」: 1,
               「kernelMatrix」:「0 -1 0 -1 {25-強度} -1 0 -1 0」}
    シャープでsvgをSVG行列畳み込み。
ここまで。

●(svgを)SVG画像ネガポジ
    ネガポジ＝{"type": ["linear","linear","linear",""],
               "slope": [-1,-1,-1,""],
               "intercept": [1,1,1,""]}
    svgをネガポジでSVG色成分変換。
ここまで。

●(Aでsvgを)SVG画像モノクロ　# 二値化
    0でSVG画像彩度補正。
    二値化＝{"type": "linear", "slope": 255 ,"intercept": -1*A}
    svgを二値化でSVG色成分変換。
ここまで。

//キャンバスのと同じ色味にするには0.45で逆ガンマ補正→実際の画像処理→2.2でガンマ補正。
●(Aでsvgを)SVG画像ガンマ補正
    ガンマ補正＝{"type": "gamma", "exponent": A}
    svgをガンマ補正でSVG色成分変換。
ここまで。

●(Aでsvgを)SVG画像コントラスト
    コントラスト＝{"type": "linear", "slope": A ,"intercept": -1*(0.5*A)+0.5}
    svgをコントラストでSVG色成分変換。
ここまで。

●(Aでsvgを)SVG画像明度補正
    明度＝{"type": "linear", "slope": A}
    svgを明度でSVG色成分変換。
ここまで。

●(Aでsvgを)SVG画像ノイズ
    前画像＝SVGフィルター前画像取得。
    [0.8,1]のSVGフラクタルノイズ。
    ノイズ＝{"type":["discrete","discrete","discrete","linear"], "tableValues":["0,1","0,1","0,1",""],"slope":["","","",255], "intercept":["","","",-200+A]}
    ノイズでSVG色成分変換。
    それと前画像を「soft-light」でSVG画像ブレンド。
    svgにそれと前画像を「in」でSVG画像合成。
ここまで

●(svgを)SVG画像グレイスケール
    svgを0でSVG画像彩度補正。
ここまで。

//セピアという名称ですが、グレイスケール化したものに特定の色でフィルタ掛ける感じ。
//rgbは[R,G,B]または「#RRGGBB」。カラーネームや色定数は使えません。
//「#EE9966」あたりがいい感じ？
●(rgbでsvgを)SVG画像セピア
    もし、（rgbの1だけ文字左部分）＝「#」ならば、rgb＝rgbのRGB分解。
    ３回。rgb[回数-1]＝rgb[回数-1]/255。。。
    r,g,b＝rgb。
    値＝「{0.2126*r} {0.7152*r} {0.0722*r} 0 0
          {0.2126*g} {0.7152*g} {0.0722*g} 0 0
          {0.2126*b} {0.7152*b} {0.0722*b} 0 0
           0 0 0 1 0」
    svgを値にSVG色行列変換。
ここまで。

●(svgを|svgへ)SVG画像線画変換
    1でSVG画像膨張。
    それと「元画像」を「difference」でSVG画像ブレンド。
    線画＝svgのSVG画像明度抽出。
    線画＝{"type": "gamma", "amplitude": 1.1, "exponent": 0.6, "offset": -0.1}でSVG色成分変換。
    背景＝白色でSVG画像塗り潰し。
    svgで[背景,線画]をSVG画像マージ。
ここまで。

# エッジフィルタなんかいろいろある・・・
変数 SVGエッジフィルター＝{
     「種別」:[「ラプシアン4」,「ラプシアン8」,「ソーベルx」,「ソーベルy」,「ロバーツx」,「ロバーツy」,「プレヴィットx」,「プレヴィットy」],
     「ラプシアン4」:"0 1 0 1 -4 1 0 1 0",//4近傍
     「ラプシアン8」:"1 1 1 1 -8 1 1 1 1",//8近傍
     「ソーベルx」:「-1 0 1 -2 0 2 -1 0 1」,
     「ソーベルy」:「-1 -2 -1 0 0 0 1 2 1」,
     「ロバーツx」:「0 0 0 0 1 0 0 0 -1」,
     「ロバーツy」:「0 0 0 0 0 1 0 -1 0」,
     「プレヴィットx」:「-1 0 1 -1 0 1 -1 0 1」,
     「プレヴィットy」:「-1 -1 -1 0 0 0 1 1 1」
}
●(svgを|svgへAで)SVG画像エッジ変換
    もし、A＝空ならば、A＝「ソーベルy」
    もし((Aの変数型確認)＝「number」)ならば、A＝SVGエッジフィルター["種別"][A]
    エッジ＝{「order」: 3, 「divisor」: 1,「preserveAlpha」:「true」}
    エッジ["kernelMatrix"]＝SVGエッジフィルター[A]
    エッジでsvgをSVG行列畳み込み。
ここまで。

＃＃＃画像セピアで使用
●(色を|色の)RGB分解
　分色とは変数。分色＝空配列。
　色＝色の「#」を「0x」に置換。
　色＝色を整数変換。
　数を２から０まで繰り返す
　　分色[数]＝色%256。
　　色＝(色-分色[数])/256
　ここまで。
　分色で戻る。
ここまで。

＃＃＃前画像
●SVGフィルター前画像取得
    SVG対象フィルターのDOM末尾子要素取得。
    もし、それがNULLでなければ、それの「result」をSVG属性取得して戻る。
    違えば、「元画像」を戻す。
ここまで。

＃＃追加画像処理フィルター
# 陰色は塗り色と塗り透明度を使用
●(位置と強度でsvgに|svgへ位置の)SVGドロップシャドウ　# feDropShadow
    EL＝「feDropShadow」のSVGエレメント作成。
    変数 [dx,dy]＝位置。
    もし、dy＝未定義ならば、dy＝dx。
    ELに{「dx」:dx,「dy」:dy,「stdDeviation」:強度,
         「flood-color」:SVG描画設定情報["塗"]["fill"],
         「flood-opacity」:SVG描画設定情報["塗"]["fill-opacity"]}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(svgを|svgへ)SVG画像エンボス変換
    0でSVG画像彩度補正。
    エンボス＝{「order」: 3, 「divisor」: 1,「preserveAlpha」:「true」,「bias」: 0.5,
               「kernelMatrix」:"-5 0 0 0 5 0 0 0 0"}
    エンボスでsvgをSVG行列畳み込み。
ここまで。

●(svgの|svgからAで)SVG画像輪郭抽出
    もし、A＝空ならば、A＝「ラプシアン8」
    もし((Aの変数型確認)＝「number」)ならば、A＝SVGエッジフィルター["種別"][A]
    輪郭＝{「order」: 3, 「divisor」: 1,「preserveAlpha」:「true」,「bias」:1}
    輪郭["kernelMatrix"]＝SVGエッジフィルター[A]
    輪郭でsvgをSVG行列畳み込み。
ここまで。

●(色とサイズにsvgを|サイズで色の)SVG画像縁取り
    前画像＝SVGフィルター前画像取得。
    縁取り＝サイズでSVG画像膨張。
    縁色＝色でSVG画像塗り潰し。
    縁色と縁取りを「in」でSVG画像合成。
    それと「元画像」を「out」でSVG画像合成。
    svgで[前画像,それ]をSVG画像マージ。
ここまで。

●(強度で|強度にsvgを)SVG画像粒子拡散
    前画像＝SVGフィルター前画像取得。
    ノイズ＝0.8のSVGフラクタルノイズ。
    「0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1」でSVG色行列変換。
    それと前画像を「soft-light」でSVG画像ブレンド。
    それと前画像を「in」でSVG画像合成。
    それとノイズを強度でsvgにSVG変位マップ。
ここまで。

＃＃基本フィルター
# 透明度は塗り透明度を使用。
●(色でsvgを)SVG画像塗り潰し　# feFlood
    EL＝「feFlood」のSVGエレメント作成。
    ELの「flood-color」に色をSVG属性設定。
    もし、色＝空ならば、ELの「flood-color」にSVG描画設定情報["塗"]["fill"]をSVG属性設定。
    ELの「flood-opacity」にSVG描画設定情報["塗"]["fill-opacity"]をSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(位置にsvgを)SVG画像ズラし　# feOffset
    変数 [dx,dy]＝位置。
    EL＝「feOffset」のSVGエレメント作成。
    ELの「dx」にdxをSVG属性設定。
    ELの「dy」にdyをSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(Aをsvgで|svgに)SVG画像敷き詰め　# feTile
    もし、(DOM和スタイルにAが辞書キー存在）ならば、A＝DOM和スタイル[A]。
    EL＝「feTile」のSVGエレメント作成。
    ELの「in」にAをSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(imgをsvgのxywhに|xywhへ)SVG画像挿入　# feImage
    変数 [x,y,w,h]＝xywh。
    EL＝「feImage」のSVGエレメント作成。
    ELに{「href」:img,「x」:x,「y」:y,「width」:w,「height」:h}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

＃＃＃色変換
# 色の行列変換
●(値で|値にsvgを)SVG色行列変換　# feColorMatrix
    EL＝「feColorMatrix」のSVGエレメント作成。
    ELの「type」に「matrix」をSVG属性設定。
    ELの「values」に値をSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(値でsvgを)SVG画像彩度補正
    EL＝「feColorMatrix」のSVGエレメント作成。
    ELの「type」に「saturate」をSVG属性設定。
    ELの「values」に値をSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(値でsvgを)SVG画像色相回転
    EL＝「feColorMatrix」のSVGエレメント作成。
    ELの「type」に「hueRotate」をSVG属性設定。
    ELの「values」に値をSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(svgの)SVG画像明度抽出
    EL＝「feColorMatrix」のSVGエレメント作成。
    ELの「type」に「luminanceToAlpha」をSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

# 色の変換
●(objでsvgを)SVG色成分変換　# feComponentTransfer,feFuncR,feFuncG,feFuncB,feFuncA
    EL＝「feComponentTransfer」のSVGエレメント作成。
    もし、svg＝空ならば、re＝SVG対象フィルターにELをSVGフィルター追加。
    違えば、re＝SVG対象フィルターでsvgにELをSVGフィルター直接設定。
    # 省略があった場合objから設定を作る。
    変数 設定＝空辞書。
    objを反復
        もし、((対象の変数型確認)!==「object」)ならば、
            設定[対象キー]＝空配列。
            4回。設定[対象キー][回数-1]＝対象。。。
        違えば、
            設定＝objを配列複製。
        ここまで。
    ここまで。
    色=["R","G","B","A"]。各色EL＝空配列。
    4回
        C=回数-1。
        もし、設定["type"][C]===空ならば、抜ける。
        違えば、各色EL[C]＝「feFunc{色[C]}」のSVGエレメント作成。
        設定を反復
            値＝対象[C]
            もし、値===空でなければ、各色EL[C]の対象キーに値をSVG属性設定。
        ここまで。
        ELへ各色EL[C]をDOM子要素追加。
    ここまで。
    reを戻す。
ここまで。

＃＃＃画像を合成
# PorterDuff合成
/*
operator
・over：inの画像優先。
・in：inとin2の共通部分。
・out：in2の部分をくり抜く。
・atop：in2の領域にinの画像を重ねる。
・xor：共通部分をくり抜く。
・arithmetic：2つの画像の共通部分に応じた合成演算を行う。
}
*/
●(AとBをoperatorでsvgに)SVG画像合成　# feComposite
    もし、(DOM和スタイルにAが辞書キー存在）ならば、A＝DOM和スタイル[A]。
    もし、(DOM和スタイルにBが辞書キー存在）ならば、B＝DOM和スタイル[B]。
    EL＝「feComposite」のSVGエレメント作成。
    ELに{「in」:A,「in2」:B,「operator」:operator}をSVG属性一括設定。
    もし、operator＝「arithmetic」ならば、ELに{"k1":"0.5","k2":"0.5","k3":"0.5","k4":"0"}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

# ブレンド
/*
mode
・normal：通常
・multiply：乗算
・screen：スクリーン合成
・darken：比較暗
・lighten：比較明
*/
●(AとBをmodeでsvgに)SVG画像ブレンド　# feBlend
    もし、(DOM和スタイルにAが辞書キー存在）ならば、A＝DOM和スタイル[A]。
    もし、(DOM和スタイルにBが辞書キー存在）ならば、B＝DOM和スタイル[B]。
    EL＝「feBlend」のSVGエレメント作成。
    ELに{「in」:A,「in2」:B,「mode」:mode}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。


# 重ね合わせ
//A配列に指定したものを順に重ねていく。
●(Aをsvgで)SVG画像マージ　# feMerge,feMergeNode
    EL＝「feMerge」のSVGエレメント作成。
    もし、svg＝空ならば、re＝SVG対象フィルターにELをSVGフィルター追加。
    違えば、re＝SVG対象フィルターでsvgにELをSVGフィルター直接設定。
    Aを反復
        Node＝「feMergeNode」のSVGエレメント作成。
        in＝対象。
        もし、(DOM和スタイルに対象が辞書キー存在）ならば、in＝DOM和スタイル[対象]。
        Nodeの「in」にinをSVG属性設定。
        ELへNodeをDOM子要素追加。
    ここまで。
    reを戻す。
ここまで。


＃＃拡張フィルター
●(objでsvgを|svgに)SVG行列畳み込み　# feConvolveMatrix
    EL＝「feConvolveMatrix」のSVGエレメント作成。
    ELにobjをSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

//scale:ずらす幅
●(AとBをscaleでsvgに)SVG変位マップ　# feDisplacementMap
    EL＝「feDisplacementMap」のSVGエレメント作成。
    ELに{「in」:A, 「in2」:B, 「scale」:scale,「xChannelSelector」:「R」}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

＃＃＃画像の侵食・膨張
# 暗い/値の小さい所が広がる
# radiusは処理の半径。
●(radiusでsvgを)SVG画像浸食
    EL＝「feMorphology」のSVGエレメント作成。
    ELの「operator」に「erode」をSVG属性設定。
    ELの「radius」にradiusをSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

# 明るい/値の大きい所が広がる
●(radiusでsvgを)SVG画像膨張
    EL＝「feMorphology」のSVGエレメント作成。
    ELの「operator」に「dilate」をSVG属性設定。
    ELの「radius」にradiusをSVG属性設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

＃＃＃パーリンノイズ
/*
強度は[baseFrequency,numOctaves]の配列。
・baseFrequency：ノイズ関数の周波数(x y)。大きくなるほど細かくなる。1より小さい値を指定。
・numOctaves：ノイズ関数に対するオクターブ。大きくなるほどより複雑になる。1以上の整数を指定。
*/
●(強度でsvgへ|svgに強度の)SVG乱気流
    変数 [f,o]＝強度。もし、o＝未定義ならば、o＝1。
    EL＝「feTurbulence」のSVGエレメント作成。
    # 「stitch」継ぎ目をつなぐ。「noStitch」にするとつながない。
    ELに{「type」:「turbulence」,「stitchTiles」:「stitch」,
         「baseFrequency」:f,「numOctaves」:o}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

●(強度でsvgへ|svgに強度の)SVGフラクタルノイズ
    変数 [f,o]＝強度。もし、o＝未定義ならば、o＝1。
    EL＝「feTurbulence」のSVGエレメント作成。
    ELに{「type」:「fractalNoise」,「stitchTiles」:「stitch」,
         「baseFrequency」:f,「numOctaves」:o}をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

＃＃＃照明効果と光源
/*
設定は[色,高さ,拡散]の配列。または、普通に一括設定。
・lighting-color：光の色
・surfaceScale：不透明度が1の部分の高さ
・diffuseConstant：照明の拡散度合い
*/
●(設定でsvgへ|svgに色の)SVG照明効果
    もし、(設定＝空)または(設定に「0」が辞書キー存在する)ならば、
        オプションリスト＝["lighting-color","surfaceScale","diffuseConstant"]
        設定からオプションリストで一括設定辞書作成して設定に代入。
    ここまで。
    EL＝「feDiffuseLighting」のSVGエレメント作成。
    ELに設定をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

/*
設定は[色,高さ,拡散,反射度]の配列。または普通に一括設定。
・lighting-color：光の色
・surfaceScale：不透明度が1の部分の高さ
・diffuseConstant：照明の拡散度合い
・specularExponent：照明の反射度合い(1～128)
*/
●(設定でsvgへ|svgに色の)SVG鏡面反射効果
    もし、(設定＝空)または(設定に「0」が辞書キー存在する)ならば、
        オプションリスト＝["lighting-color","surfaceScale","diffuseConstant","specularExponent"]
        設定からオプションリストで一括設定辞書作成して設定に代入。
    ここまで。
    EL＝「feSpecularLighting」のSVGエレメント作成。
    ELに設定をSVG属性一括設定。
    もし、svg＝空ならば、SVG対象フィルターにELをSVGフィルター追加。
    違えば、SVG対象フィルターでsvgにELをSVGフィルター直接設定。
ここまで。

＃＃＃＃光源
/*
方向角は[azimuth,elevation]の配列。
・azimuth：光点の水平方向角。
・elevation：光点の垂直方向角。
*/
●(照明フィルターに方向角の|照明フィルターへ方向角で)SVG平行光源設定
    EL＝「feDistantLight」のSVGエレメント作成。
    水平方向角,垂直方向角＝方向角。
    ELに{「azimuth」:水平方向角,「elevation」:垂直方向角}をSVG属性一括設定。
    照明フィルターのDOM要素ID取得にELをDOM子要素追加。
ここまで。

/*
xyzは[x,y,z]の配列。
・x：光源の横位置
・y：光源の縦位置
・z：光源の高さ
*/
●(照明フィルターにxyzの)SVG点光源設定
    EL＝「fePointLight」のSVGエレメント作成。
    x,y,z＝xyz。//光源の位置
    ELに{「x」:x,「y」:y,「z」:z}をSVG属性一括設定。
    照明フィルターのDOM要素ID取得にELをDOM子要素追加。
ここまで。

/*
設定は[[x,y,z],[px,py,pz],[範囲角],[反射度]]の配列。または、普通に一括設定。
・x,y,z：光源の位置
・pointsAtX,pointsAtY,pointsAtZ：光の向き
・limitingConeAngle：光が拡散する円錐の範囲角
・specularExponent：光の反射度合い
*/
●(照明フィルターに設定の)SVGスポットライト設定
    もし、(設定＝空)または(設定に「0」が辞書キー存在する)ならば、
        x,y,z＝設定[0]。px,py,pz＝設定[1]。
        設定配列＝[x,y,z,px,py,pz,設定[2],設定[3]]
        オプションリスト＝["x","y","z","pointsAtX","pointsAtY","pointsAtZ","limitingConeAngle","specularExponent"]。

        設定配列からオプションリストで一括設定辞書作成して設定に代入。
    ここまで。
    EL＝「feSpotLight」のSVGエレメント作成。
    ELに設定をSVG属性一括設定。
    照明フィルターのDOM要素ID取得にELをDOM子要素追加。
ここまで。

＃＃配列で設定して辞書型にする
●(設定配列からオプションリストで)一括設定辞書作成
    設定＝空辞書。C=0。
    オプションリストを反復
        もし、(設定配列[C]＝空)または(設定配列[C]＝未定義)でなければ、設定[対象]＝設定配列[C]。        C=C+1。
    ここまで。
    設定を戻す。
ここまで。

#-----------------------------------------------
#-----------------------------------------------
＃アニメーション
#-----------------------------------------------
/*
・「attributeType」「XML」(全部属性で指定しているのでXML)
・「repeatCount」「indefinite」（無限ループ。または0以上の数値）
*/
●(svgの属性へ|属性に時間とキーフレームで)SVGアニメーション設定
    EL＝「animate」のSVGエレメント作成。
    ELに{「attributeName」:属性,
         「attributeType」:「XML」,「values」:キーフレーム,
         「dur」:時間,「repeatCount」:「indefinite」}をSVG属性一括設定。
    svgへELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgの変形タイプに|変形タイプへ時間とキーフレームで)SVG変形アニメーション設定
    EL＝「animateTransform」のSVGエレメント作成。
    ELに{「attributeName」:「transform」,「type」:変形タイプ,
         「attributeType」:「XML」,「values」:キーフレーム,
         「dur」:時間,「repeatCount」:「indefinite」}をSVG属性一括設定。
    svgへELをDOM子要素追加。
    ELを戻す。
ここまで。

# 既存のパスを使う場合は、d属性を取得。
●(svgを|svgに|svgへ時間とパスで)SVGモーションアニメーション設定
    EL＝「animateMotion」のSVGエレメント作成。
    ELに{「path」:パス,「dur」:時間,「repeatCount」:「indefinite」}をSVG属性一括設定。
    svgへELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃変形
#キャンバスのとは違い今あるSVGを変化させる。グループ(g)などに適用すれば、まとめて変化させられる。
# transform(https://developer.mozilla.org/ja/docs/Web/SVG/Attribute/transform)
#-----------------------------------------------
●(svgをAだけ|Aに|Aへ)SVG描画変換マトリクス設定
    svgの「transform」に「matrix({A[0]},{A[1]},{A[2]},{A[3]},{A[4]},{A[5]})」をSVG属性設定。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画変換マトリクス追加
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    svgの「transform」に「{既存値} matrix({A[0]},{A[1]},{A[2]},{A[3]},{A[4]},{A[5]})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

# Translateを追加ではなく先頭で行うことで変形してるやつも見た目通りに移動する。
●(svgをXYだけ|XYに|XYへ)SVG描画起点移動　# Translate
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    X,Y＝XY。
    もし、Y＝未定義ならば、Y=0。
    svgの「transform」に「translate({X},{Y}) {既存値}」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをXYだけ|XYに|XYへ)SVG描画移動　# Translate
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    X,Y＝XY。
    もし、Y＝未定義ならば、Y=0。
    svgの「transform」に「{既存値} translate({X},{Y})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをXYだけ|XYに|XYへ)SVG描画拡大　# Scale
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    X,Y＝XY。
    もし、Y＝未定義ならば、Y=X。
    svgの「transform」に「{既存値} scale({X},{Y})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画回転　# Rotate
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    A,CX,CY=A。
    もし、(CX≠未定義)かつ(CY≠未定義)ならば、A=「{A},{CX},{CY}」
    svgの「transform」に「{既存値} rotate({A})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画傾斜X　# SkewX
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    svgの「transform」に「{既存値} skewX({A})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画傾斜Y　# SkewY
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    svgの「transform」に「{既存値} skewY({A})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgの)SVG描画変形削除　# transform属性の内容を破棄。
    svgの「transform」に空をSVG属性設定。
ここまで。

●(svgの)SVG変換マトリクス統合
    変形リスト＝svg["transform"]["baseVal"]。
    変形リスト要素数＝変形リスト["numberOfItems"]。
    仮SVG＝「document」の「createElementNS」を['http://www.w3.org/2000/svg','svg']でJSメソッド実行。
    MTX＝仮SVGの「createSVGMatrix」を空でJSメソッド実行。
    変形リスト要素数回
        変形リストの「getItem」を回数-1でJSメソッド実行。
        MTX=MTXの「multiply」をそれ["matrix"]でJSメソッド実行。
    ここまで。
    matrix＝「matrix({MTX["a"]},{MTX["b"]},{MTX["c"]},{MTX["d"]},{MTX["e"]},{MTX["f"]})」
    svgの「transform」にmatrixをSVG属性設定。
ここまで。

●(svgの)CTM取得　# Current Transformation Matrix
    CTM=svgの「getCTM」を空でJSメソッド実行。
    「matrix({CTM["a"]},{CTM["b"]},{CTM["c"]},{CTM["d"]},{CTM["e"]},{CTM["f"]})」を戻す。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃ダウンロード
#-----------------------------------------------
●(ファイル名でsvgを)SVGダウンロード
    もし、ファイル名＝空ならば、ファイル名＝「nako3_SVG.svg」
    SVGテキスト＝svg["outerHTML"]。
    BLOB＝SVGテキストを{"type":"application/xml"}でBLOB作成。
    URL＝「URL.createObjectURL」を[BLOB]でJS関数実行。
    A＝「a」のDOM部品作成。# 仮のaタグ。
    Aの「download」にファイル名をDOM属性設定。
    Aの「href」にURLをDOM属性設定。
    Aの「click」を空でJSメソッド実行。
    DOM親要素からAをDOM子要素削除。# 消して終了。
    「window.URL.revokeObjectURL」を[URL]でJS関数実行。# 解放して終了。
ここまで。

●(svgをファイル名で|ファイル名へ|ファイル名に)PNGダウンロード
    もし、ファイル名＝空ならば、ファイル名＝「nako3_SVG.png」
    SVGテキスト＝svg["outerHTML"]。
    IMGデータ＝「"data:image/svg+xml;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent('{SVGテキスト}')))」をJS実行。
    w＝svgの「width」をSVG属性取得。
    h＝svgの「height」をSVG属性取得。
    [w,h]のキャンバス作成して描画開始。# 仮のキャンバス
    A＝「a」のDOM部品作成。# 仮のaタグ
    Aの「download」にファイル名をDOM属性設定。# ファイル名を仮設定。
    IMGデータの画像読んだ時には、
      [0,0]に対象を画像描画。# SVGのデータスキームを仮のキャンバスに描画。
      A=「nadesi-dom-{DOM部品個数-1}」のDOM要素ID取得。
      ファイル名＝Aの「download」をDOM属性取得。
      Aに描画ダウンロードリンク作成。# 「download」が「canvas.png」に設定されてしまう。
      Aの「download」にファイル名をDOM属性設定。# ファイル名を再設定。
      Aの「click」を空でJSメソッド実行。
      DOM親要素からAをDOM子要素削除。# 全部消して終了。
      DOM親要素から描画中キャンバスをDOM子要素削除。
    ここまで。
ここまで。

# 描画中キャンバスの[0,0]へ描画する
●(svgを)SVGキャンバス描画
    SVGテキスト＝svg["outerHTML"]。
    IMGデータ＝「"data:image/svg+xml;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent('{SVGテキスト}')))」をJS実行。
    IMGデータの画像読んだ時には、
        [0,0]に対象を画像描画。
    ここまで。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃ドラッグ＆ドロップ
#-----------------------------------------------
# ドラッグ許可するのは、動かしたいSVGではなくその親要素。
●(DOMで|DOMの|DOMを|DOMに)SVGドラッグ許可
    DOMの「mousemove」に「SVGドラッグ移動処理」をDOMイベント追加。
    DOMの「touchmove」に「SVGドラッグ移動処理」をDOMイベント追加。
    DOMの「mouseup」に「SVGドラッグ終了処理」をDOMイベント追加。
    DOMの「touchend」に「SVGドラッグ終了処理」をDOMイベント追加。
ここまで。
●(DOMで|DOMの|DOMを|DOMに)SVGドラッグ許可取消し
    SVGドラッグ情報["移動中フラグ"]＝空。
    SVGドラッグ情報["移動中要素"]＝空。
    SVGドラッグ情報["変形既存値"]＝空。
    DOMの「mousemove」から「SVGドラッグ移動処理」をDOMイベント削除。
    DOMの「touchmove」から「SVGドラッグ移動処理」をDOMイベント削除。
    DOMの「mouseup」から「SVGドラッグ終了処理」をDOMイベント削除。
    DOMの「touchend」から「SVGドラッグ終了処理」をDOMイベント削除。
ここまで。

# 動かしたいSVG要素を個別にオンオフする
●(SVGの|SVGを|SVGに)SVGドラッグオン
    SVGの「mousedown」に「SVGドラッグ開始処理」をDOMイベント追加。
    SVGの「touchstart」に「SVGドラッグ開始処理」をDOMイベント追加。
ここまで。
●(SVGの|SVGを|SVGに)SVGドラッグオフ
    SVGの「mousedown」から「SVGドラッグ開始処理」をDOMイベント削除。
    SVGの「touchstart」から「SVGドラッグ開始処理」をDOMイベント削除。
ここまで。

# 実際の処理
●SVGドラッグ開始処理とは
    対象イベントのDOMイベント処理停止。
    SVGドラッグ情報["移動中フラグ"]＝オン。
    SVGドラッグ情報["移動中要素"]＝対象。
    SVGドラッグ情報["変形既存値"]＝SVGドラッグ情報["移動中要素"]の「transform」をSVG属性取得。
    もし、それ＝NULLならば、SVGドラッグ情報["変形既存値"]＝空。
    もし、対象イベントに「changedTouches」が辞書キー存在するならば、
        SVGドラッグ情報["元x"]＝対象イベント["changedTouches"][0]["pageX"]。
        SVGドラッグ情報["元y"]＝対象イベント["changedTouches"][0]["pageY"]。
    違えば、
        SVGドラッグ情報["元x"]＝対象イベント["pageX"]。
        SVGドラッグ情報["元y"]＝対象イベント["pageY"]。
    ここまで。
ここまで。

●SVGドラッグ移動処理とは
    もし、SVGドラッグ情報["移動中フラグ"]＝オンならば、
        もし、対象イベントに「changedTouches」が辞書キー存在するならば、
            今x＝対象イベント["changedTouches"][0]["pageX"]-SVGドラッグ情報["元x"]。
            今y＝対象イベント["changedTouches"][0]["pageY"]-SVGドラッグ情報["元y"]。
        違えば、
            今x＝対象イベント["pageX"]-SVGドラッグ情報["元x"]。
            今y＝対象イベント["pageY"]-SVGドラッグ情報["元y"]。
        ここまで。
        SVGドラッグ情報["移動中要素"]の「transform」に「translate({今x},{今y}) {SVGドラッグ情報["変形既存値"]}」をSVG属性設定。
        SVGドラッグ情報["移動中要素"]のSVG変換マトリクス統合。
    ここまで。
ここまで。

●SVGドラッグ終了処理とは
    SVGドラッグ情報["移動中フラグ"]＝オフ。
    SVGドラッグ情報["移動中要素"]＝空。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃重なり設定
#-----------------------------------------------
# 記述した順に重なっていくので、最後に追加すると最前面になり、最初に挿入すると最背面となる。
●(svgを)SVG最前面
    親＝svgのDOM親要素取得。
    svgを親にDOM子要素追加。
ここまで。

●(svgを)SVG最背面
    親＝svgのDOM親要素取得。
    最初＝親のDOM初子要素取得。
    親の最初へsvgをDOM子要素挿入。
ここまで。

●(svgを要素の)SVG背面
    親＝svgのDOM親要素取得。
    もし、要素＝NULLならば、要素＝親のDOM初子要素取得。
    親の要素へsvgをDOM子要素挿入。
ここまで。

●(svgを要素の)SVG前面
    親＝svgのDOM親要素取得。
    次要素＝要素のDOM次要素取得。
    親の次要素へsvgをDOM子要素挿入。
ここまで。

＃＃DOMプラス
●(DOMの)DOM親要素取得
    DOM["parentNode"]で戻る。
ここまで。

//要素中の最初の子要素
●(DOMの)DOM初子要素取得
    DOM["firstChild"]で戻る。
ここまで。
//要素中の最後の子要素
●(DOMの)DOM末尾子要素取得
    DOM["lastChild"]で戻る。
ここまで。

//同じ階層の前の要素
●(DOMの)DOM前要素取得
    DOM["previousSibling"]で戻る。
ここまで。
//同じ階層の次の要素
●(DOMの)DOM次要素取得
    DOM["nextSibling"]で戻る。
ここまで。

●(親要素の参照先へ|参照先に子要素を)DOM子要素挿入
    親要素の「insertBefore」を[子要素,参照先]でJSメソッド実行。
ここまで。
#-----------------------------------------------