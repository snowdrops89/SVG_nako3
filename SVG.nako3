#-----------------------------------------------
＃ 【 SVG描画 】　0.5.0
//・重なりの設定。
#-----------------------------------------------
＃定数宣言
定数 無色＝「none」。
定数 SVGデフォルト値一覧＝{
    "stroke":無色,
    "stroke-width":1,
    "stroke-opacity":1,
    "stroke-linecap":"butt",
    "stroke-linejoin":"miter",
    "stroke-dasharray":"none",
    "stroke-dashoffset":0,
    "fill":黒色,
    "fill-opacity":1,
    "font-family":空,
    "font-weight":"normal",
    "font-size":"medium",
}

＃変数宣言
変数 SVG要素作成個数＝0。
変数 SVG描画設定情報＝{
  "線":{
    "stroke":無色,
    "stroke-width":1,
    "stroke-opacity":1,
    "stroke-linecap":"butt",
    "stroke-linejoin":"miter",
    "stroke-dasharray":"none",
    "stroke-dashoffset":0,
  },
  "塗":{
    "fill":黒色,
    "fill-opacity":1,
  },
  "文字":{
    "font-family":空,
    "font-weight":"normal",
    "font-size":"medium",
  }
}
変数 SVGパス作成情報＝{"連続パス作成中フラグ":オフ}
変数 SVGドラッグ情報＝{"移動中フラグ":オフ}

SVG和スタイル追加。
●SVG和スタイル追加
　追加和スタイル＝{
    "線色": "stroke",
    "線太":"stroke-width",
    "線太さ":"stroke-width",
    "線透明度":"stroke-opacity",
    "線端形状":"stroke-linecap",
    "端切":"butt",
    "円":"round",
    "丸":"round",
    "四角":"square",
    "角形状":"stroke-linejoin",
    "鋭角":"miter",
    "丸め":"round",
    "面取":"bevel",
    "面取り":"bevel",
    "破線パターン":"stroke-dasharray",
    "破線開始位置":"stroke-dashoffset",
    "塗色": "fill",
    "塗り色": "fill",
    "塗透明度":"fill-opacity",
    "塗り透明度":"fill-opacity",
    "透明度":"opacity",
    "フォント名":"font-family",
    "文字太":"font-weight",
    "文字太さ":"font-weight",
    "文字間":"letter-spacing",
  }
　追加和スタイルを反復
　　DOM和スタイル[対象キー]＝対象。
　ここまで。
ここまで。
#-----------------------------------------------
＃描画開始
//単なるDOM要素設定だけど、キャンバスの描画命令に寄せる＆クリップやマスクの描画開始が分かりやすくなる感。
●(svgの|svgへ|svgで)SVG描画開始
    svgへDOM親要素設定。
ここまで。
#-----------------------------------------------
＃図形描画
＃＃線
●(xy1からxy2まで|xy2へ)SVG線描画
    変数 [x1,y1]＝xy1。
    変数 [x2,y2]＝xy2。
    EL＝「line」のSVGエレメント作成。
    ELの「x1」にx1をSVG属性設定。
    ELの「y1」にy1をSVG属性設定。
    ELの「x2」にx2をSVG属性設定。
    ELの「y2」にy2をSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

＃＃四角
●(xywhの|xywhへ|xywhに)SVG四角描画
    変数 [x,y,w,h]＝xywh。
    EL＝「rect」のSVGエレメント作成。
    ELの「x」にxをSVG属性設定。
    ELの「y」にyをSVG属性設定。
    ELの「width」にwをSVG属性設定。
    ELの「height」にhをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(xywhへrの|xywhにrで)SVG角丸四角描画
    もし、r[1]＝未定義ならば、r＝[r,r]。
    変数 [x,y,w,h]＝xywh。
    変数 [rx,ry]＝r。
    EL＝「rect」のSVGエレメント作成。
    ELの「x」にxをSVG属性設定。
    ELの「y」にyをSVG属性設定。
    ELの「width」にwをSVG属性設定。
    ELの「height」にhをSVG属性設定。
    ELの「rx」にrxをSVG属性設定。
    ELの「ry」にryをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

＃＃円、楕円
●(xyへrの|xyに)SVG円描画
    変数 [x,y]＝xy。
    EL＝「circle」のSVGエレメント作成。
    ELの「cx」にxをSVG属性設定。
    ELの「cy」にyをSVG属性設定。
    ELの「r」にrをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

●(xyへrの|xyに)SVG楕円描画
    もし、r[1]＝未定義ならば、r＝[r,r]。
    変数 [x,y]＝xy。
    変数 [rx,ry]＝r。
    EL＝「ellipse」のSVGエレメント作成。
    ELの「cx」にxをSVG属性設定。
    ELの「cy」にyをSVG属性設定。
    ELの「rx」にrxをSVG属性設定。
    ELの「ry」にryをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

＃＃ポリゴン、ポリライン
# PはSVGの記述通り「x1,y1 x2,y2 x3,y3...」と、なでしこのキャンバスのと同じ配列での指定ができる[[x2,y1],[x2,y2],[x3,y3]...]
# 線だけにしたい場合は、SVG塗り色を「none」にする。
●(Pの|Pで)SVG折れ線描画
    もし、(Pの変数型確認)＝「object」ならば、P=Pを「 」で配列結合。
    EL＝「polyline」のSVGエレメント作成。
    ELの「points」にPをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

●(Pの|Pで)SVG多角形描画
    もし、(Pの変数型確認)＝「object」ならば、P=Pを「 」で配列結合。
    EL＝「polygon」のSVGエレメント作成。
    ELの「points」にPをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。
#-----------------------------------------------
＃文字描画
●(xyへSの|xyにSを)SVG文字描画
    変数 [x,y]＝xy。
    EL＝「text」のSVGエレメント作成。
    ELの「x」にxをSVG属性設定。
    ELの「y」にyをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    ELにSVG描画設定情報["文字"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELにSをテキスト設定。
    ELを戻す。
ここまで。

●(xyへSの|xyにSを)SVG縦書き文字描画
    変数 [x,y]＝xy。
    EL＝「text」のSVGエレメント作成。
    ELの「x」にxをSVG属性設定。
    ELの「y」にyをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    ELにSVG描画設定情報["文字"]をSVG描画初期設定。
    ELの「writing-mode」に「vertical-rl」をSVG属性設定。
    ELの「text-orientation」に「mixed」をSVG属性設定。
    DOM親要素へELをDOM子要素追加。
    ELにSをテキスト設定。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃パス描画
●(dの|dを|dで)SVGパス描画
    EL＝「path」のSVGエレメント作成。
    ELの「d」にdをSVG属性設定。
    ELにSVG描画設定情報["線"]をSVG描画初期設定。
    ELにSVG描画設定情報["塗"]をSVG描画初期設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

＃＃連続パス描画
//連続パス描画中は始点を省略してつないでいく。
●(始点から|始点に|始点へ)SVG連続パス描画開始
    SVGパス作成情報["連続パス作成中フラグ"]＝オン。
    SVGパス作成情報["d"]＝空。
    もし、(始点＝空)または((始点の要素数)≠2)でなければ、SVGパス作成情報["d"]＝「M {始点[0]},{始点[1]} 」
    SVGパス作成情報["d"]で戻る。
ここまで。

●SVG連続パス描画終了
    SVGパス作成情報["連続パス作成中フラグ"]＝オフ。
    SVGパス作成情報["d"]でSVGパス描画。
ここまで。

●(追加パスで)SVG連続パス追加処理
    SVGパス作成情報["d"]＝SVGパス作成情報["d"]&追加パス。
    SVGパス作成情報["d"]で戻る。
ここまで。

//連続パス描画でだけ
●(xyへ|xyに|xyまで)SVGパス描画位置移動
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オフならば、戻る。
    追加パス＝「M {xy[0]},{xy[1]} 」
    追加パスでSVG連続パス追加処理して、戻る。
ここまで。

＃＃線
●(xy1からxy2まで|xy2へ)SVGパス線描画
    x1,y1＝xy1。x2,y2＝xy2。
    始点＝「M {x1},{y1} 」。追加パス＝「L {x2},{y2} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
    d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

＃＃弧
//設定配列=[回転度,弧が180度より大きいか,時計回りか]
●(始点から終点まで設定配列で半径の)SVG弧形描画
    始点＝「M {始点[0]},{始点[1]} 」。
    もし、設定配列＝空ならば、設定配列＝[0,0,1]。
    回転度,大弧,右回転＝設定配列。
    半径x,半径y＝半径。もし、半径y＝未定義ならば、半径y＝半径x。
    追加パス＝「A {半径x},{半径x} {回転度} {大弧} {右回転} {終点[0]} {終点[1]} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
    d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

# 角度はラジアン。角度0は右端。
●(中点に開始角から終了角まで半径の|中点へ半径で)SVG扇描画
    中点x,中点y＝中点。
    開始角＝開始角のラジアン角度修正。
    終了角＝終了角のラジアン角度修正。
    半径x,半径y＝半径。もし、半径y＝未定義ならば、半径y＝半径x。
    x1＝半径x*COS(開始角)＋中点x。
    y1＝半径y*SIN(開始角)＋中点y。
    x2＝半径x*COS(終了角)＋中点x。
    y2＝半径y*SIN(終了角)＋中点y。
    回転度＝0。     # 回転度
    大弧＝いいえ。  # 弧が180度より大きいか
    もし、終了角＜開始角ならば、終了角＝終了角+(360をラジアン変換)
    もし、終了角-開始角＞(180をラジアン変換)ならば、大弧＝はい。
    右回転＝はい。  # 時計回りか
    d＝「M {中点x},{中点y} L {x1},{y1} A {半径x},{半径y} {回転度} {大弧} {右回転} {x2},{y2} z 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、dでSVG連続パス追加処理して、戻る。
    dでSVGパス描画。
ここまで。

●(中点に開始角から終了角まで半径の|中点へ半径で)SVG円弧描画
    中点x,中点y＝中点。
    開始角＝開始角のラジアン角度修正。
    終了角＝終了角のラジアン角度修正。
    半径x,半径y＝半径。もし、半径y＝未定義ならば、半径y＝半径x。
    x1＝半径x*COS(開始角)＋中点x。
    y1＝半径y*SIN(開始角)＋中点y。 
    x2＝半径x*COS(終了角)＋中点x。
    y2＝半径y*SIN(終了角)＋中点y。
    回転度＝0。     # 回転度
    大弧＝いいえ。  # 弧が180度より大きいか
    もし、終了角＜開始角ならば、終了角＝終了角+(360をラジアン変換)
    もし、終了角-開始角＞(180をラジアン変換)ならば、大弧＝はい。
    右回転＝はい。  # 時計回りか
    d＝「M {x1},{y1} A {半径x},{半径y} {回転度} {大弧} {右回転} {x2},{y2} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、dでSVG連続パス追加処理して、戻る。
    dでSVGパス描画。
ここまで。

●(ラジアン度の)ラジアン角度修正　//0～360をラジアン変換の範囲に修正
    修正ラジアン度＝ラジアン度%(360をラジアン変換)
    もし、修正ラジアン度＜０ならば、修正ラジアン度＝修正ラジアン度+(360をラジアン変換)
    修正ラジアン度で戻る。
ここまで。

＃＃スプライン
●(始点から中継点配列で)SVGスプライン描画
    始点＝「M {始点[0]},{始点[1]} 」
    追加パス＝空。
　　中継点配列を反復
　　　　点x,点y＝中継点配列[対象キー]
　　　　追加パス＝追加パス&「T {点x},{点y} 」
　　ここまで。
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
　　d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

＃＃ベジェ曲線
# 終点を配列にして複数指定すると、スプラインでつないでいく。
●(始点から制御点で終点まで|始点と終点の)SVG二次ベジェ曲線描画
    始点＝「M {始点[0]},{始点[1]} 」
    制御点＝「Q {制御点[0]},{制御点[1]} 」
    追加パス＝制御点。
    もし、(終点[0]の要素数)＝１ならば、
        追加パス＝追加パス&「{終点[0]},{終点[1]} 」
    違えば、
        終点を反復
            もし、対象キー≠0ならば、追加パス＝追加パス&「T 」。
            追加パス＝追加パス&「{対象[0]},{対象[1]} 」。
        ここまで。
    ここまで。
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
　　d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

●(始点から制御点配列で終点まで|始点と終点の)SVG三次ベジェ曲線描画
    始点＝「M {始点[0]},{始点[1]} 」
    制御点A,制御点B＝制御点配列。
    追加パス＝「C {制御点A[0]},{制御点A[1]} {制御点B[0]},{制御点B[1]} {終点[0]},{終点[1]} 」
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オンならば、追加パスでSVG連続パス追加処理して、戻る。
　　d＝始点&追加パス。
    dでSVGパス描画。
ここまで。

//連続パス描画でだけ
●(制御点で終点まで|終点と)SVG三次ベジェ曲線続ける
    もし、SVGパス作成情報["連続パス作成中フラグ"]＝オフならば、戻る。
    もし、(終点[0]の要素数)＝1ならば、
        追加パス＝「S {制御点[0]},{制御点[1]} {終点[0]},{終点[1]} 」
        追加パスでSVG連続パス追加処理して、戻る。
    違えば、
        (終点の要素数)回。
            終点x,終点y＝終点[回数-1]。
            制御点x,制御点y＝制御点[回数-1]。
            追加パス＝「S {制御点x},{制御点y} {終点x},{終点y} 」
            追加パスでSVG連続パス追加処理。
        ここまで。
        戻る。
    ここまで。
ここまで。
#-----------------------------------------------
＃画像描画
# 幅と高さの指定が必須ラシイ(無くても等幅で表示される気がするけどいちおう)
# https://developer.mozilla.org/ja/docs/Web/SVG/Element/image
●(xywhへURLの|xywhにURLを)SVG画像描画
    x,y,w,h＝xywh。
    EL＝「image」のSVGエレメント作成。
    ELの「x」にxをSVG属性設定。
    ELの「y」にyをSVG属性設定。
    ELの「width」にwをSVG属性設定。
    ELの「height」にhをSVG属性設定。
    ELの「href」にURLをSVG属性設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。
#-----------------------------------------------
＃作成
●(要素種別の)SVGエレメント作成。
    EL＝「document」の「createElementNS」を['http://www.w3.org/2000/svg',要素種別]でJSメソッド実行。
    ELの「id」に「nako3-svg-{SVG要素作成個数}」をSVG属性設定。
    SVG要素作成個数＝SVG要素作成個数+1。
    ELを戻す。
ここまで。

＃＃ＳＶＧ親要素
●(whの|whで)SVG親要素作成
    変数 [w,h]＝wh。
    EL＝「svg」のSVGエレメント作成。
    ELの「setAttribute」を['xmlns','http://www.w3.org/2000/svg']でJSメソッド実行。
    ELの「setAttribute」を['xmlns:xlink','http://www.w3.org/1999/xlink']でJSメソッド実行。
    ELの「viewBox」に「0 0 {w} {h}」をSVG属性設定。
    ELの「width」にwをSVG属性設定。
    ELの「height」にhをSVG属性設定。
    DOM親要素へELをDOM子要素追加。
    ELへDOM親要素設定。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃＃グループ
# グループ化。表示される。スタイルやトランスフォーム属性を指定すると一括で指定される。
●(親要素へ|親要素に)SVGグループ作成
    もし、親要素＝空ならば、親要素＝DOM親要素。
    EL＝「g」のSVGエレメント作成。
    親要素へELをDOM子要素追加。
    ELを戻す。 
ここまで。

# ここに描画したものは表示されない。参照複製(use)して使うものを定義しておく所。
# viewbox を指定でき、参照複製時、width, height を指定して拡縮できる（？）
# 基本、定義領域(defs)に作成する。
●(親要素へ|親要素に)SVGシンボルグループ作成
    もし、親要素＝空ならば、親要素＝DOM親要素。
    EL＝「symbol」のSVGエレメント作成。
    親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。

# シンボルグループやスタイルシートなど実際に描画しないものを定義しておく所。
# 参照される要素は可能な限り、ここに入れておけとゆうことラシイ（？）
●(親要素へ|親要素に)SVG定義領域作成
    もし、親要素＝空ならば、親要素＝DOM親要素。
    EL＝「defs」のSVGエレメント作成。
    親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃＃参照複製
# 参照元の塗り色や線色や変形は継承されて上書き出来ないので気を付ける。
# 参照元は、シンボルグループの中に、スタイル属性やトランスフォーム属性は基本付けず作成。
# 色関係の変数には空を設定しておく。
# use(https://developer.mozilla.org/ja/docs/Web/SVG/Element/use)
●(svgを)SVG参照複製
    ID＝svgの「id」をSVG属性取得。
    EL＝「use」のSVGエレメント作成。
    ELの「href」に「#{ID}」をSVG属性設定。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃＃その他の要素
# 一応何でも作れるようにしておく
●(要素種別の)SVG要素作成。
    EL＝要素種別のSVGエレメント作成。
    DOM親要素へELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
＃設定と取得
# なでしこのDOM属性設定、取得命令では、SVGはできない。
# 「setAttribute」でいいのか「setAttributeNS」が正しいのか、なやむー。
●(svgの属性に値を|属性へ)SVG属性設定
    もし、(DOM和スタイルに属性が辞書キー存在）ならば、属性＝DOM和スタイル[属性]。
    もし、(DOM和スタイルに値が辞書キー存在）ならば、値＝DOM和スタイル[値]。
    svgの「setAttributeNS」を[NULL,属性,値]でJSメソッド実行。
ここまで。

●(svgに|svgへ設定を)SVG属性一括設定
    設定を反復
        属性＝対象キー。値＝対象。
        svgの属性に値をSVG属性設定。
    ここまで。
ここまで。

●(svgの属性を|属性から)SVG属性取得
    もし、(DOM和スタイルに属性が辞書キー存在）ならば、属性＝DOM和スタイル[属性]。
    svgの「getAttributeNS」を[NULL,属性]でJSメソッド実行。
ここまで。
#-----------------------------------------------
＃＃描画初期設定
#描画要素作成時に使う一括設定。
# スタイルやトランスフォームは直接指定すると、
# 　・優先順位によりクラスでの指定が効かなくなる。
# 　・参照複製時にも継承されて上書きできない。
# 　そうゆう用途の場合は、空またはデフォルト値にしておくことで設定しないようにする。
●(svgに設定を)SVG描画初期設定
    設定を反復
        属性＝対象キー。値＝対象。デフォルト値＝SVGデフォルト値一覧[属性]。
        もし、(値≠デフォルト値)かつ(値!==空)ならば、svgの属性に値をSVG属性設定。
    ここまで。
ここまで。
#-----------------------------------------------
＃＃描画スタイル設定
#なでしこのキャンバスの描画と同様、これから描画するやつに適用される。
●(Vに|Vへ)SVG線色設定
    SVG描画設定情報["線"]["stroke"]＝V。
ここまで。

●(Vに|Vへ)SVG塗色設定
    SVG描画設定情報["塗"]["fill"]＝V。
ここまで。

●(Vに|Vへ)SVG線太設定
    SVG描画設定情報["線"]["stroke-width"]＝V。
ここまで。

# [線透明度,塗り透明度]。値が一つの時は同じになる。
●(Vに|Vへ)SVG透明度設定
    線,塗＝V。
    もし、塗＝未定義ならば、塗＝V。
    SVG描画設定情報["線"]["stroke-opacity"]＝線。
    SVG描画設定情報["塗"]["fill-opacity"]＝塗。
ここまで。

●(Vに|Vへ)SVG線端形状設定
    もし、(DOM和スタイルにVが辞書キー存在）ならば、V＝DOM和スタイル[V]。
    SVG描画設定情報["線"]["stroke-linecap"]＝V。
ここまで。

●(Vに|Vへ)SVG角形状設定
    もし、(DOM和スタイルにVが辞書キー存在）ならば、V＝DOM和スタイル[V]。
    SVG描画設定情報["線"]["stroke-linejoin"]＝V。
ここまで。

＃＃フォント設定
●(Vに|Vへ)SVG文字フォント設定
    SVG描画設定情報["文字"]["font-family"]＝V。
ここまで。

●(Vに|Vへ)SVG文字太さ設定
    SVG描画設定情報["文字"]["font-weight"]＝V。
ここまで。

●(Vに|Vへ)SVG文字サイズ設定
    SVG描画設定情報["文字"]["font-size"]＝V。
ここまで。
#-----------------------------------------------
＃＃破線・点線
●(Aに|Aへ)SVG破線パターン設定
    もし、(Aの変数型確認)＝「object」でなければ、
        SVG線太さ＝SVG描画設定情報["線"]["stroke-width"]。
        「端切」にSVG線端形状設定。
        Aで条件分岐
            「丸点線」ならば、
                「丸」にSVG線端形状設定。
                A＝「1 {SVG線太さ*2}」。
            ここまで。
            「細点線」ならば、A＝SVG線太さ。。。
            「点線」ならば、A＝SVG線太さ*2。。。
            「破線」ならば、A＝「{SVG線太さ*4} {SVG線太さ*2}」。。。
            「一点鎖線」ならば、A＝「{SVG線太さ*6} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2}」。。。
            「中長破線」ならば、A＝「{SVG線太さ*6} {SVG線太さ*2}」。。。
            「長破線」ならば、A＝「{SVG線太さ*8} {SVG線太さ*2}」。。。
            「長鎖線」ならば、A＝「{SVG線太さ*8} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2}」。。。
            「二点鎖線」ならば、A＝「{SVG線太さ*8} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2} {SVG線太さ*2}」。。。
            違えば、A＝「」。。。
    　　ここまで。
　　ここまで。
　　SVG描画設定情報["線"]["stroke-dasharray"]＝A。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃効果
#-----------------------------------------------
＃＃画像切り抜き
# クリッピングパスを定義して置く所。この中に描画したものは表示されず、画像切り抜きで設定して使う。
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGクリップパス作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「clipPath」のSVGエレメント作成。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgをクリップパスで)SVG画像切り抜き
    ID=クリップパスの「id」をSVG属性取得。
    svgの「clip-path」に「url(#{ID})」をSVG属性設定。
ここまで。
#-----------------------------------------------
＃＃マスキング
# マスクを定義しておく所。白色で描画した所は表示され、黒色または透明度０で描画した所は非表示になる。白色に透明度を設定すれば、半透明にもできる。
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGマスク作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「mask」のSVGエレメント作成。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgをマスクで)SVG画像マスキング
    ID=マスクの「id」をSVG属性取得。
    svgの「mask」に「url(#{ID})」をSVG属性設定。
ここまで。

＃＃グラデーション
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域にstop配列で)SVG線形グラデーション作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
　　EL＝「linearGradient」のSVGエレメント作成。
　　定義領域へELをDOM子要素追加。
　　stop配列を反復
　　　　stop＝「stop」のSVGエレメント作成。
　　　　stopの「offset」に対象[0]をSVG属性設定。
　　　　stopの「stop-color」に対象[1]をSVG属性設定。
　　　　もし、対象[2]≠未定義ならば、stopの「stop-opacity」に対象[2]をSVG属性設定。
　　　　ELへstopをDOM子要素追加。
　　ここまで。
    ELを戻す。
ここまで。

●(定義領域へ|定義領域にstop配列で)SVG放射状グラデーション作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
　　EL＝「radialGradient」のSVGエレメント作成。
　　定義領域へELをDOM子要素追加。
　　stop配列を反復
　　　　stop＝「stop」のSVGエレメント作成。
　　　　stopの「offset」に対象[0]をSVG属性設定。
　　　　stopの「stop-color」に対象[1]をSVG属性設定。
　　　　もし、対象[2]≠未定義ならば、stopの「stop-opacity」に対象[2]をSVG属性設定。
　　　　ELへstopをDOM子要素追加。
　　ここまで。
    ELを戻す。
ここまで。

●(svgの属性に|属性へグラデーションを)SVGグラデーション設定
    ID＝グラデーションの「id」をSVG属性取得。
    svgの属性に「url(#{ID})」をSVG属性設定。
ここまで。
#-----------------------------------------------
＃＃タイルパターン
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域にwhで)SVGタイルパターン作成。
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    幅,高さ＝wh。
    EL＝「pattern」のSVGエレメント作成。
    ELの「幅」に幅をSVG属性設定。
    ELの「高さ」に高さをSVG属性設定。
    # 適用先のサイズがどうでも、パターンのサイズ、比率は変えたくない。
    ELの「patternUnits」に「userSpaceOnUse」をSVG属性設定。
    ELの「patternContentUnits」に「userSpaceOnUse」をSVG属性設定。
    # 適用先の画像に対する比率で位置やサイズを設定する場合の設定。
    //ELの「patternUnits」に「objectBoundingBox」をSVG属性設定。
    //ELの「patternContentUnits」に「objectBoundingBox」をSVG属性設定。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgの属性に|属性へタイルパターンを)SVGタイルパターン設定
    ID=タイルパターンの「id」をSVG属性取得。
    # 適用先の画像の0,0からパターンが始まるようにする。
    x=svgの「x」をSVG属性取得。
    y=svgの「y」をSVG属性取得。
    タイルパターンの「x」にxをSVG属性設定。
    タイルパターンの「y」にyをSVG属性設定。
    svgの属性に「url(#{ID})」をSVG属性設定。
ここまで。
#-----------------------------------------------
＃＃フィルター
# 基本、定義領域(defs)に作成する。
●(定義領域へ|定義領域に)SVGフィルター作成
    もし、定義領域＝空ならば、定義領域＝DOM親要素。
    EL＝「filter」のSVGエレメント作成。
    ELの「filterUnits」に「userSpaceOnUse」をSVG属性設定。
    定義領域へELをDOM子要素追加。
    ELを戻す。
ここまで。

●(フィルターでsvgに強度の|強度へ)SVG画像ボカシ
    EL＝「feGaussianBlur」のSVGエレメント作成。
    ELの「stdDeviation」に強度をSVG属性設定。
    re＝ELの「id」をSVG属性取得。
    ELの「result」にreをSVG属性設定。
    フィルターへELをDOM子要素追加。
    ID＝フィルターの「id」をSVG属性取得。
    svgの「filter」に「url(#{ID})」をSVG属性設定。
    reを戻す。
ここまで。

●(フィルターでsvgに位置と|位置へ強度の)SVGドロップシャドウ
    # 影を付けるソース画像
    ソース＝「SourceGraphic」
    もし、フィルター["lastChild"]＝ NULLでなければ、ソース＝フィルター["lastChild"]["id"]。//すでに定義されているフィルタがある場合は、それに重ねがけする
    # 影を作成
    EL＝「feGaussianBlur」のSVGエレメント作成。
    ELの「in」に「SourceAlpha」をSVG属性設定。
    ELの「stdDeviation」に強度をSVG属性設定。
    ELの「result」に「影」をSVG属性設定。
    フィルターへELをDOM子要素追加。
    # 影の位置を設定
    dx,dy＝位置。
    もし、dy＝未定義ならば、dy＝dx。
    EL＝「feOffset」のSVGエレメント作成。
    ELの「in」に「影」をSVG属性設定。
    ELの「dx」にdxをSVG属性設定。
    ELの「dy」にdyをSVG属性設定。
    ELの「result」に「影」をSVG属性設定。
    フィルターへELをDOM子要素追加。
    # 元画像に影を重ね合わせます。
    EL＝「feComposite」のSVGエレメント作成。
    ELの「in」にソースをSVG属性設定。
    ELの「in2」に「影」をSVG属性設定。
    re＝ELの「id」をSVG属性取得。
    ELの「result」にreをSVG属性設定。
    フィルターへELをDOM子要素追加。
    # 設定
    ID＝フィルターの「id」をSVG属性取得。
    svgの「filter」に「url(#{ID})」をSVG属性設定。
    reを戻す。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃アニメーション
#-----------------------------------------------
●(svgの属性へ|属性に時間とキーフレームで)SVGアニメーション設定
    EL＝「animate」のSVGエレメント作成。
    ELの「attributeType」に「XML」をSVG属性設定。// XML/CSS(全部属性で指定しているのでXML)
    ELの「attributeName」に属性をSVG属性設定。
    ELの「dur」に時間をSVG属性設定。
    ELの「values」にキーフレームをSVG属性設定。
    ELの「repeatCount」に「indefinite」をSVG属性設定。//無限ループ。または0以上の数値。
    svgへELをDOM子要素追加。
    ELを戻す。
ここまで。

●(svgの変形タイプに|変形タイプへ時間とキーフレームで)SVG変形アニメーション設定
    EL＝「animateTransform」のSVGエレメント作成。
    ELの「attributeType」に「XML」をSVG属性設定。// XML/CSS(全部属性で指定しているのでXML)
    ELの「attributeName」に「transform」をSVG属性設定。
    ELの「type」に変形タイプをSVG属性設定。
    ELの「dur」に時間をSVG属性設定。
    ELの「values」にキーフレームをSVG属性設定。
    ELの「repeatCount」に「indefinite」をSVG属性設定。//無限ループ。または0以上の数値。
    svgへELをDOM子要素追加。
    ELを戻す。
ここまで。

# 既存のパスを使う場合は、d属性を取得。
●(svgを|svgに|svgへ時間とパスで)SVGモーションアニメーション設定
    EL＝「animateMotion」のSVGエレメント作成。
    ELの「path」にパスをSVG属性設定。
    ELの「dur」に時間をSVG属性設定。
    ELの「repeatCount」に「indefinite」をSVG属性設定。//無限ループ。または0以上の数値。
    svgへELをDOM子要素追加。
    ELを戻す。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃変形
#キャンバスのとは違い今あるSVGを変化させる。グループ(g)などに適用すれば、まとめて変化させられる。
# transform(https://developer.mozilla.org/ja/docs/Web/SVG/Attribute/transform)
#-----------------------------------------------
●(svgをAだけ|Aに|Aへ)SVG描画変換マトリクス設定
    svgの「transform」に「matrix({A[0]},{A[1]},{A[2]},{A[3]},{A[4]},{A[5]})」をSVG属性設定。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画変換マトリクス追加
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    svgの「transform」に「{既存値} matrix({A[0]},{A[1]},{A[2]},{A[3]},{A[4]},{A[5]})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

# Translateを普通に追加。キャンバスのと同様。名前も合わせる。
●(svgをXYに|XYへ)SVG描画起点設定　# Translate
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    X,Y＝XY。
    もし、Y＝未定義ならば、Y=0。
    svgの「transform」に「{既存値} translate({X},{Y})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

# Translateを追加ではなく先に行うことで変形してるやつも見た目通りに移動する。
●(svgをXYだけ|XYに|XYへ)SVG描画移動　# Translate
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    X,Y＝XY。
    もし、Y＝未定義ならば、Y=0。
    svgの「transform」に「translate({X},{Y}) {既存値}」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをXYだけ|XYに|XYへ)SVG描画拡大　# Scale
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    X,Y＝XY。
    もし、Y＝未定義ならば、Y=X。
    svgの「transform」に「{既存値} scale({X},{Y})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画回転　# Rotate
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    A,CX,CY=A。
    もし、(CX≠未定義)かつ(CY≠未定義)ならば、A=「{A},{CX},{CY}」
    svgの「transform」に「{既存値} rotate({A})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画傾斜X　# SkewX
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    svgの「transform」に「{既存値} skewX({A})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgをAだけ|Aに|Aへ)SVG描画傾斜Y　# SkewY
    既存値＝svgの「transform」をSVG属性取得。
    もし、既存値＝NULLならば、既存値＝空。
    svgの「transform」に「{既存値} skewY({A})」をSVG属性設定。
    svgのSVG変換マトリクス統合。
ここまで。

●(svgの)SVG描画変形削除　# transform属性の内容を破棄。
    svgの「transform」に空をSVG属性設定。
ここまで。

●(svgの)SVG変換マトリクス統合　# Current Transformation Matrix
    A=svgの「getCTM」を空でJSメソッド実行。
    svgの「transform」に「matrix({A["a"]},{A["b"]},{A["c"]},{A["d"]},{A["e"]},{A["f"]})」をSVG属性設定。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃ダウンロード
#-----------------------------------------------
●(ファイル名でsvgを)SVGダウンロード
    もし、ファイル名＝空ならば、ファイル名＝「nako3_SVG.svg」
    SVGテキスト＝svg["outerHTML"]の改行を空に置換。//改行入ってるとダメ。
    blobURL＝「const blob=new Blob(['{SVGテキスト}']);//文中に"があるかもなので''で囲う。
    window.URL.createObjectURL(blob)」をJS実行。
    A＝「a」のDOM部品作成。//仮のaタグ。
    Aの「download」にファイル名をDOM属性設定。
    Aの「href」にblobURLをDOM属性設定。
    Aの「click」を空でJSメソッド実行。
    DOM親要素からAをDOM子要素削除。//消して終了。
ここまで。

●(ファイル名でsvgを)PNGダウンロード
    もし、ファイル名＝空ならば、ファイル名＝「nako3_SVG.png」
    XMLS＝「new XMLSerializer();」をJS実行。
    SVGデータ＝XMLSの「serializeToString」をsvgでJSメソッド実行。
    IMGデータ＝「"data:image/svg+xml;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent('{SVGデータ}')))」をJS実行。
    w＝svgの「width」をSVG属性取得。
    h＝svgの「height」をSVG属性取得。
    [w,h]のキャンバス作成して描画開始。//仮のキャンバス
    A＝「a」のDOM部品作成。//仮のaタグ
    Aの「ファイル名」にファイル名をDOM属性設定。
    IMGデータの画像読んだ時には、
      [0,0]に対象を画像描画。//SVGのデータスキームを仮のキャンバスに描画。
      A=「nadesi-dom-{DOM部品個数-1}」のDOM要素ID取得。
      ファイル名＝Aの「ファイル名」をDOM属性取得。
      Aに描画ダウンロードリンク作成。
      Aの「download」にファイル名をDOM属性設定。
      Aの「click」を空でJSメソッド実行。
      DOM親要素からAをDOM子要素削除。//全部消して終了。
      DOM親要素から描画中キャンバスをDOM子要素削除。
    ここまで。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃ドラッグ＆ドロップ
#-----------------------------------------------
# ドラッグ許可するのは、動かしたいSVGではなくその親要素。
●(DOMで|DOMの|DOMを|DOMに)SVGドラッグ許可
    DOMの「mousemove」に「SVGドラッグ移動処理」をDOMイベント追加。
    DOMの「touchmove」に「SVGドラッグ移動処理」をDOMイベント追加。
    DOMの「mouseup」に「SVGドラッグ終了処理」をDOMイベント追加。
    DOMの「touchend」に「SVGドラッグ終了処理」をDOMイベント追加。
ここまで。
●(DOMで|DOMの|DOMを|DOMに)SVGドラッグ許可取消し
    SVGドラッグ情報["移動中フラグ"]＝空。
    SVGドラッグ情報["移動中要素"]＝空。
    SVGドラッグ情報["変形既存値"]＝空。
    DOMの「mousemove」から「SVGドラッグ移動処理」をDOMイベント削除。
    DOMの「touchmove」から「SVGドラッグ移動処理」をDOMイベント削除。
    DOMの「mouseup」から「SVGドラッグ終了処理」をDOMイベント削除。
    DOMの「touchend」から「SVGドラッグ終了処理」をDOMイベント削除。
ここまで。

# 動かしたいSVG要素を個別にオンオフする
●(SVGの|SVGを|SVGに)SVGドラッグオン
    SVGの「mousedown」に「SVGドラッグ開始処理」をDOMイベント追加。
    SVGの「touchstart」に「SVGドラッグ開始処理」をDOMイベント追加。
ここまで。
●(SVGの|SVGを|SVGに)SVGドラッグオフ
    SVGの「mousedown」から「SVGドラッグ開始処理」をDOMイベント削除。
    SVGの「touchstart」から「SVGドラッグ開始処理」をDOMイベント削除。
ここまで。

# 実際の処理
●SVGドラッグ開始処理とは
    対象イベントのDOMイベント処理停止。
    SVGドラッグ情報["移動中フラグ"]＝オン。
    SVGドラッグ情報["移動中要素"]＝対象。
    SVGドラッグ情報["変形既存値"]＝SVGドラッグ情報["移動中要素"]の「transform」をSVG属性取得。
    もし、それ＝NULLならば、SVGドラッグ情報["変形既存値"]＝空。
    もし、対象イベントに「changedTouches」が辞書キー存在するならば、
        SVGドラッグ情報["元x"]＝対象イベント["changedTouches"][0]["pageX"]。
        SVGドラッグ情報["元y"]＝対象イベント["changedTouches"][0]["pageY"]。
    違えば、
        SVGドラッグ情報["元x"]＝対象イベント["pageX"]。
        SVGドラッグ情報["元y"]＝対象イベント["pageY"]。
    ここまで。
ここまで。

●SVGドラッグ移動処理とは
    もし、SVGドラッグ情報["移動中フラグ"]＝オンならば、
        もし、対象イベントに「changedTouches」が辞書キー存在するならば、
            今x＝対象イベント["changedTouches"][0]["pageX"]-SVGドラッグ情報["元x"]。
            今y＝対象イベント["changedTouches"][0]["pageY"]-SVGドラッグ情報["元y"]。
        違えば、
            今x＝対象イベント["pageX"]-SVGドラッグ情報["元x"]。
            今y＝対象イベント["pageY"]-SVGドラッグ情報["元y"]。
        ここまで。
        SVGドラッグ情報["移動中要素"]の「transform」に「translate({今x},{今y}) {SVGドラッグ情報["変形既存値"]}」をSVG属性設定。
        SVGドラッグ情報["移動中要素"]のSVG変換マトリクス統合。
    ここまで。
ここまで。

●SVGドラッグ終了処理とは
    SVGドラッグ情報["移動中フラグ"]＝オフ。
    SVGドラッグ情報["移動中要素"]＝空。
ここまで。
#-----------------------------------------------
#-----------------------------------------------
＃重なり設定
#-----------------------------------------------
# 記述した順に重なっていくので、最後に追加すると最前面になり、最初に挿入すると再背面となる。
●(svgを)SVG最前面
    親＝svgのDOM親要素取得。
    svgを親にDOM子要素追加。
ここまで。

●(svgを)SVG最背面
    親＝svgのDOM親要素取得。
    最初＝親のDOM初子要素取得。
    親の最初へsvgをDOM子要素挿入。
ここまで。

●(svgを要素の)SVG背面
    親＝svgのDOM親要素取得。
    もし、要素＝NULLならば、要素＝親のDOM初子要素取得。
    親の要素へsvgをDOM子要素挿入。
ここまで。

●(svgを要素の)SVG前面
    親＝svgのDOM親要素取得。
    次要素＝要素のDOM次要素取得。
    親の次要素へsvgをDOM子要素挿入。
ここまで。

＃＃DOMプラス
●(DOMの)DOM親要素取得
    DOM["parentNode"]で戻る。
ここまで。

//要素中の最初の子要素
●(DOMの)DOM初子要素取得
    DOM["firstChild"]で戻る。
ここまで。
//要素中の最後の子要素
●(DOMの)DOM末尾子要素取得
    DOM["lastChild"]で戻る。
ここまで。

//同じ階層の前の要素
●(DOMの)DOM前要素取得
    DOM["previousSibling"]で戻る。
ここまで。
//同じ階層の次の要素
●(DOMの)DOM次要素取得
    DOM["nextSibling"]で戻る。
ここまで。

●(親要素の参照先へ|参照先に子要素を)DOM子要素挿入
    親要素の「insertBefore」を[子要素,参照先]でJSメソッド実行。
ここまで。
#-----------------------------------------------
